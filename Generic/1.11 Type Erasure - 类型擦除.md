### 1.11 Type Erasure - 类型擦除
泛型被引入到 Java 语言中，以便在编译时提供更严格的类型检查并支持泛型编程。为了实现泛型，Java 编译器将类型擦除应用于：

- 替换泛型类型中的所有类型参数，如果类型参数是有界的，则将其替换为第一个边界，如果类型参数是无界的，则将其替换为 Object。因此，生成的字节码仅包含普通的类、接口和方法。
- 如有必要，插入类型转换以保持类型安全。
- 生成桥接方法以保留扩展泛型类型中的多态性。

类型擦除确保不为参数化类型创建新类，因此，泛型不会产生运行时开销。

#### 1.11.1 Erasure of Generic Types - 擦除泛型类型
在类型擦除过程中，Java 编译器将擦除所有类型参数，并在类型参数有界时将其替换为第一个边界，如果类型参数为无界，则替换为 Object。

考虑以下表示单链表中节点的泛型类：

```
public class Node<T> {

    private T data;
    private Node<T> next;

    public Node(T data, Node<T> next) {
        this.data = data;
        this.next = next;
    }

    public T getData() { return data; }
    // ...
}
```

因为类型参数 T 是无界的，所以 Java 编译器将其替换为 Object：

```
public class Node {

    private Object data;
    private Node next;

    public Node(Object data, Node next) {
        this.data = data;
        this.next = next;
    }

    public Object getData() { return data; }
    // ...
}
```

在以下示例中，泛型 Node 类使用有界类型参数：

```
public class Node<T extends Comparable<T>> {

    private T data;
    private Node<T> next;

    public Node(T data, Node<T> next) {
        this.data = data;
        this.next = next;
    }

    public T getData() { return data; }
    // ...
}
```

Java 编译器将有界类型参数 T 替换为第一个边界类 Comparable：

```
public class Node {

    private Comparable data;
    private Node next;

    public Node(Comparable data, Node next) {
        this.data = data;
        this.next = next;
    }

    public Comparable getData() { return data; }
    // ...
}
```


#### 1.11.2 Erasure of Generic Methods
Java 编译器还会擦除泛型方法参数中的类型参数。请细想以下泛型方法：

```
// Counts the number of occurrences of elem in anArray.
public static <T> int count(T[] anArray, T elem) {
    int cnt = 0;
    for (T e : anArray)
        if (e.equals(elem))
            ++cnt;
        return cnt;
}
```

因为 T 是无界的，所以 Java 编译器将它替换为 Object：

```
public static int count(Object[] anArray, Object elem) {
    int cnt = 0;
    for (Object e : anArray)
        if (e.equals(elem))
            ++cnt;
        return cnt;
}
```

假设定义了以下类：

```
class Shape { /* ... */ }
class Circle extends Shape { /* ... */ }
class Rectangle extends Shape { /* ... */ }
```

您可以编写一个泛型方法来绘制不同的形状：

```public static <T extends Shape> void draw(T shape) { /* ... */ }```

Java 编译器将 T 替换为 Shape：

```public static void draw(Shape shape) { /* ... */ }```

#### 1.11.3 Effects of Type Erasure and Bridge Methods
有时类型擦除会导致您可能没有预料到的情况，以下示例显示了如何发生这种情况。示例（在 Bridge 方法中描述 ）显示了编译器有时如何创建一个称为桥接方法的合成方法，作为类型擦除过程的一部分。

给出以下两个类：

```
public class Node<T> {

    public T data;

    public Node(T data) { this.data = data; }

    public void setData(T data) {
        System.out.println("Node.setData");
        this.data = data;
    }
}

public class MyNode extends Node<Integer> {
    public MyNode(Integer data) { super(data); }

    public void setData(Integer data) {
        System.out.println("MyNode.setData");
        super.setData(data);
    }
}
```

请细想以下代码：

```
MyNode mn = new MyNode(5);
Node n = mn;            // A raw type - compiler throws an unchecked warning
n.setData("Hello");     
Integer x = mn.data;    // Causes a ClassCastException to be thrown.
```

在类型擦除后，此代码变为：

```
MyNode mn = new MyNode(5);
Node n = (MyNode)mn;         // A raw type - compiler throws an unchecked warning
n.setData("Hello");
Integer x = (String)mn.data; // Causes a ClassCastException to be thrown.
```

以下是执行代码时发生的情况：

- n.setData("Hello"); causes the method setData(Object) to be executed on the object of class MyNode. (The MyNode class inherited setData(Object) from Node.)
- In the body of setData(Object), the data field of the object referenced by n is assigned to a String.
- The data field of that same object, referenced via mn, can be accessed and is expected to be an integer (since mn is a MyNode which is a Node<Integer>.
- Trying to assign a String to an Integer causes a ClassCastException from a cast inserted at the assignment by a Java compiler.

##### Bridge Methods
在编译 extends 参数化类或 implement 参数化接口的类或接口时，编译器可能需要创建一个称为桥接方法的合成方法，作为类型擦除过程的一部分。您通常不需要担心桥接方法，但如果出现在堆栈跟踪中，您可能会感到困惑。

在类型擦除之后，Node 和 MyNode 类变为：

```
public class Node {

    public Object data;

    public Node(Object data) { this.data = data; }

    public void setData(Object data) {
        System.out.println("Node.setData");
        this.data = data;
    }
}

public class MyNode extends Node {

    public MyNode(Integer data) { super(data); }

    public void setData(Integer data) {
        System.out.println("MyNode.setData");
        super.setData(data);
    }
}
```

在类型擦除之后，方法签名不匹配。Node 方法变为使用 `setData（Object）` 并且 MyNode 方法变成使用 `setData(Integer)`。因此，MyNode `setData` 方法不会覆盖 Node `setData`方法。

为了解决这个问题并在类型擦除后保留泛型类型的多态性，Java 编译器会生成一个桥接方法，以确保子类型按预期工作。对于 MyNode 类，编译器为 setData 生成以下桥接方法：

```
class MyNode extends Node {

    // Bridge method generated by the compiler
    //
    public void setData(Object data) {
        setData((Integer) data);
    }

    public void setData(Integer data) {
        System.out.println("MyNode.setData");
        super.setData(data);
    }

    // ...
}
```

如您所见，与类型擦除后的 Node 类的 `setData` 方法具有相同的方法签名的桥接方法，委托给原始的`setData`方法。

#### 1.11.4 Non-Reifiable Types
The section Type Erasure discusses the process where the compiler removes information related to type parameters and type arguments. Type erasure has consequences related to variable arguments (also known as varargs ) methods whose varargs formal parameter has a non-reifiable type. See the section Arbitrary Number of Arguments in Passing Information to a Method or a Constructor for more information about varargs methods.

Type Erasure 部分讨论了编译器删除与 type parameters 和 type arguments相关的信息的过程。类型擦除具有与变量参数（也称为varargs）方法相关的后果，其varargs形式参数非具体化的类型。有关可变参数方法的详细信息，请参见[Arbitrary Number of Arguments in Passing Information to a Method or a Constructor]()

此页面包含以下主题：

- Non-Reifiable Types
- Heap Pollution
- Potential Vulnerabilities of Varargs Methods with Non-Reifiable Formal Parameters
- Preventing Warnings from Varargs Methods with Non-Reifiable Formal Parameters

##### Non-Reifiable Types
可具体化类型(reifiable type)是类型信息在运行时完全可用的类型，这包括基元，非泛型类型，原始类型和无界限通配符的调用。

非具体化类型是在编译时通过类型擦除删除信息的类型 - 未定义为无界通配符的泛型类型的调用。非具体化类型在运行时没有提供所有信息，非具体化类型的示例是 List<String> 和 List<Number>，JVM 无法在运行时区分这些类型。如 "Restrictions on Generics" 中所示，在某些情况下，不能使用非具体化类型：例如，在表达式的实例中，或作为数组中的元素。

##### Heap Pollution
Heap pollution occurs when a variable of a parameterized type refers to an object that is not of that parameterized type. This situation occurs if the program performed some operation that gives rise to an unchecked warning at compile-time. An unchecked warning is generated if, either at compile-time (within the limits of the compile-time type checking rules) or at runtime, the correctness of an operation involving a parameterized type (for example, a cast or method call) cannot be verified. For example, heap pollution occurs when mixing raw types and parameterized types, or when performing unchecked casts.
当参数化类型的变量引用不是该参数化类型的对象时，会发生堆污染。如果程序执行某些操作，在编译时产生未经检查的警告，则会出现这种情况。如果在编译时（在编译时类型检查规则的限制内）或在运行时，生成涉及参数化类型（例如，强制转换或方法调用）的操作的正确性，则会生成未经检查的警告。验证。 例如，在混合原始类型和参数化类型时，或者在执行未经检查的强制转换时，会发生堆污染。

在正常情况下，当所有代码同时编译时，编译器会发出未经检查的警告，以引起您对潜在堆污染的注意。如果单独编译代码的各个部分，则很难检测到堆污染的潜在风险。如果确保代码在没有警告的情况下编译，则不会发生堆污染。
