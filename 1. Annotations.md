## 1. Annotations
**Annotations**（一种元数据形式）提供有关不属于程序本身的程序的数据。**Annotations** 对它们注释的代码的操作没有直接影响。

**Annotations** 有许多用途，其中包括：

- 编译器的信息 - 编译器可以使用 **Annotations** 来检测错误或抑制警告。
- 编译时和部署时处理 - 软件工具可以处理 **Annotations** 信息以生成代码、XML文件等。
- **Runtime** 处理 - 可以在运行时检查某些 **Annotations**。

本课程介绍了可以使用 **annotations** 的位置，如何应用 **annotations**，Java 平台，标准版（Java SE API）中可用的预定义注释类型，类型注释如何与可插入类型系统结合使用以编写更强大的代码类型检查，以及如何实现重复注释

### 1.1 Annotations Basics

#### 1.1.1 The Format of an Annotation 
在最简单的形式中，**annotation** 如下所示：

```
@Entity
```
**@** 符号向编译器指示后面的内容是 **annotation**。在以下示例中，注释的名称为 **Override**:

```
@Override
void mySuperMethod() { ... }
```

**Annotation** 可以包含可以命名或未命名的元素(elements)，并且这些元素有值：

```
@Author(
   name = "Benjamin Franklin",
   date = "3/27/2003"
)
class MyClass() { ... }
```
或者

```
@SuppressWarnings(value = "unchecked")
void myMethod() { ... }
```

如果只有一个名为value的元素，那么名称可以省略，如：

```
@SuppressWarnings("unchecked")
void myMethod() { ... }
```

如果 **annotation** 没有元素，则可以省略括号，如前面的 **@Override** 示例所示。

也可以在同一声明中使用多个注释：

```
@Author(name = "Jane Doe")
@EBook
class MyClass { ... }
```

如果 **annotations** 具有相同的类型，则称为重复注释(Repeating Annotations)：

```
@Author(name = "Jane Doe")
@Author(name = "John Smith")
class MyClass { ... }
```

从 Java SE 8 发行版开始，支持重复注释。有关更多信息，请参阅[重复注释](https://docs.oracle.com/javase/tutorial/java/annotations/repeating.html)。

**Annotation** 类型可以是 **Java SE API** 的 **java.lang** 或 **java.lang.annotation** 包中定义的类型之一。在前面的示例中，**Override** 和 **SuppressWarnings** 是预定义的 **Java** 注释。也可以定义自己的 **annotation** 类型。上一个示例中的 **Author** 和 **Ebook** 是自定义 **annotation** 类型。

#### 1.1.2 Where Annotations Can Be Used

**Annotations** 可以应用于声明（包括类、字段、方法和其他程序元素的声明）。当在声明中使用时，每个 **annotations** 通常按照惯例出现在它自己的行上。

从 **Java SE 8** 发行版开始，**Annotations** 也可以应用于类型的使用。这里有些例子：

- Class instance creation expression:

```
   new @Interned MyObject();
```

- Type cast:

```
   myString = (@NonNull String) str;
```

- implements clause:

```
   class UnmodifiableList<T> implements
	@Readonly List<@Readonly T> { ... }
```
- Thrown exception declaration:

```
	void monitorTemperature() throws
	@Critical TemperatureException { ... }
```

这种形式的 **annotation** 称为 **type annotation**。更多信息，请参阅 [Type Annotations and Pluggable Type Systems](https://docs.oracle.com/javase/tutorial/java/annotations/type_annotations.html)。


### 1.2 Declaring an Annotation Type

许多 **Annotation** 会替换代码中的注释。

假设一个软件组传统地启动每个类的主体，并提供重要信息的注释：

```
public class Generation3List extends Generation2List {

   // Author: John Doe
   // Date: 3/17/2002
   // Current revision: 6
   // Last modified: 4/12/2004
   // By: Jane Doe
   // Reviewers: Alice, Bill, Cindy

   // class code goes here

}
```

要使用 ** annotation** 添加此相同元数据，必须先定义 **annotation** 类型。这样做的语法是：

```
@interface ClassPreamble {
   String author();
   String date();
   int currentRevision() default 1;
   String lastModified() default "N/A";
   String lastModifiedBy() default "N/A";
   // Note use of array
   String[] reviewers();
}
```

**Annotation** 类型定义类似于接口定义，其中关键字接口前面带有 **@** 符号。**Annotation** 类型是一种 **interface** 形式。

前一个注释定义的主体包含注释类型元素声明，它看起来很像方法。请注意，他们可以定义可选的默认值。

定义注释类型后，您可以使用该类型的注释，并填入值，如下所示：

```
@ClassPreamble (
   author = "John Doe",
   date = "3/17/2002",
   currentRevision = 6,
   lastModified = "4/12/2004",
   lastModifiedBy = "Jane Doe",
   // Note array notation
   reviewers = {"Alice", "Bob", "Cindy"}
)

public class Generation3List extends Generation2List {

// class code goes here

}
```

注意：要使 `@ClassPreamble` 中的信息出现在 Javadoc 生成的文档中，必须使用 `@Documented` 注释 `@ClassPreamble` 定义：

```
// import this to use @Documented
import java.lang.annotation.*;

@Documented
@interface ClassPreamble {

   // Annotation element definitions
   
}
```

### 1.3 Predefined Annotation Types

Java SE API 中预定义了一组注释类型。 Java编译器使用某些注释类型，有些注释类型适用于其他注释。

#### 1.3.1 Annotation Types Used by the Java Language

**java.lang** 中定义的预定义注释类型是 `@Deprecated`、`@Override` 和 `@SuppressWarnings`。

- `@Deprecated` 表示已弃用标记的元素，不应再使用。只要程序使用带有`@Deprecated`的方法、类或字段，编译器就会生成警告。不推荐使用元素时，也应使用 Javadoc @deprecated标记对其进行记录，如以下示例所示。在 Javadoc 注释和注释中使用at符号（@）并非巧合：它们在概念上是相关的。 另请注意，Javadoc标记以小写d开头，注释以大写D开头。

```
   // Javadoc comment follows
    /**
     * @deprecated
     * explanation of why it was deprecated
     */
    @Deprecated
    static void deprecatedMethod() { }
```

- `@Override` 通知编译器该元素旨在覆盖父类中声明的元素。将在接口和继承中讨论重写方法。

```
// mark method as a superclass method
   // that has been overridden
   @Override 
   int overriddenMethod() { }
```

虽然在重写方法时不需要使用此批注，但它有助于防止出错。如果使用 `@Override` 标记的方法无法正确覆盖其某个超类中的方法，则编译器会生成错误。

- @SuppressWarnings 注释告诉编译器抑制警告否则会生成的特定警告。在以下示例中，使用了不推荐使用的方法，编译器通常会生成警告。但是，在这种情况下，注释会导致警告被抑制。

```
// use a deprecated method and tell 
   // compiler not to generate a warning
   @SuppressWarnings("deprecation")
    void useDeprecatedMethod() {
        // deprecation warning
        // - suppressed
        objectOne.deprecatedMethod();
    }
```

每个编译器警告都属于一个类别。Java语言规范列出了两个类别：弃用和未选中。 当与泛型出现之前编写的遗留代码接口时，可能会发生未经检查的警告。 要禁止多种类别的警告，请使用以下语法：

```
@SuppressWarnings({"unchecked", "deprecation"})
```

- `@SafeVarargs` 在应用于方法或构造函数时，断言代码不对其 varargs 参数执行可能不安全的操作。使用此注释类型时，将禁止与 varargs 使用相关的未经检查的警告。

- `@FunctionalInterface` **Java SE 8** 中引入的 `@FunctionalInterface` 表明类型声明旨在成为Java语言规范定义的功能接口。

#### 1.3.2 Annotations That Apply to Other Annotations

适用于其他注释的注释称为元注释。**java.lang.annotation** 中定义了几种元注释类型。

- `@Retention` 指定标记注释的存储方式：  
	RetentionPolicy.SOURCE  - 标记的注释仅保留在源级别中，并由编译器忽略。  
	RetentionPolicy.CLASS  - 标记的注释在编译时由编译器保留，但Java虚拟机（JVM）会忽略。  
	RetentionPolicy.RUNTIME  - 标记的注释由JVM保留，因此运行时环境可以使用它。  

- `@Documented` 表明无论何时使用指定的注释，都应使用 Javadoc 工具记录这些元素。（默认情况下，注释不包含在 Javadoc 中。）有关更多信息，请参阅 Javadoc 工具页面。

- `@Target` 注释标记另一个注释，以限制可以应用注释的Java元素类型。目标注释指定以下元素类型之一作为其值：

	ElementType.ANNOTATION_TYPE可以应用于注释类型。  
	ElementType.CONSTRUCTOR可以应用于构造函数。  
	ElementType.FIELD可以应用于字段或属性。  
	ElementType.LOCAL_VARIABLE可以应用于局部变量。  
	ElementType.METHOD可以应用于方法级注释。  
	ElementType.PACKAGE可以应用于包声明。  
	ElementType.PARAMETER可以应用于方法的参数。  
	ElementType.TYPE可以应用于类的任何元素。  
	
- `@Inherited` 注释表明注释类型可以从超类继承。 （默认情况下不是这样。）当用户查询注释类型并且该类没有此类型的注释时，将查询类的超类以获取注释类型。 此注释仅适用于类声明。

- `@Repeatable` Java SE 8 中引入的 @Repeatable 表明标记的注释可以多次应用于相同的声明或类型使用。有关更多信息，请参阅重复注释。

### 1.4 Type Annotations and Pluggable Type Systems

在 **Java SE 8** 发行版之前，注释只能应用于声明。从 **Java SE 8** 发行版开始，注释也可以应用于任何类型的使用。这意味着可以在使用类型的任何位置使用注释。使用where类型的一些示例是类实例创建表达式（new），强制转换，implements子句和throws子句。这种注释形式称为类型注释，注释基础知识中提供了几个示例。

创建类型注释是为了支持改进的Java程序分析，以确保更强的类型检查。**Java SE 8** 版本不提供类型检查框架，但它允许您编写（或下载）类型检查框架，该框架实现为与Java编译器结合使用的一个或多个可插入模块。

例如，您希望确保程序中的特定变量永远不会分配给null;你想避免触发NullPointerException。您可以编写自定义插件来检查此问题。然后，您将修改代码以注释该特定变量，表明它永远不会分配给null。变量声明可能如下所示：

```
@NonNull String str;
```

当您在命令行编译包括 NonNull 模块的代码时，编译器会在检测到潜在问题时输出警告，允许您修改代码以避免错误。在更正代码以删除所有警告后，程序运行时不会发生此特定错误。

您可以使用多个类型检查模块，其中每个模块检查不同类型的错误。通过这种方式，您可以在您希望的时间和地点添加构建在 Java 类型系统之上的特定检查。

通过明智地使用 **type annotations** 和可插拔类型检查器的存在，您可以编写更强大且不容易出错的代码。

在许多情况下，有第三方为您完成了这项工作，您不必编写自己的类型检查模块。例如，您可能希望使用华盛顿大学创建的 **Checker Framework**。该框架包括 **NonNull** 模块、正则表达式模块和互斥锁模块。有关更多信息，请参阅 [Checker Framework](http://types.cs.washington.edu/checker-framework/)。

### Repeating Annotations

在某些情况下，您希望将相同的注释应用于声明或类型用途。 从Java SE 8发行版开始，重复注释使您可以执行此操作。

例如，您正在编写代码以使用计时器服务，该服务使您能够在给定时间或某个计划上运行方法，类似于UNIX cron服务。 现在，您要设置一个计时器，以便在该月的最后一天和每周五的晚上11点运行方法doPeriodicCleanup。 要将计时器设置为运行，请创建@Schedule注释并将其应用于doPeriodicCleanup方法两次。 第一次使用指定月份的最后一天，第二次使用指定星期五晚上11点，如下面的代码示例所示：

```
@Schedule(dayOfMonth="last")
@Schedule(dayOfWeek="Fri", hour="23")
public void doPeriodicCleanup() { ... }
```

前面的示例将注释应用于方法。 您可以在使用标准注释的任何位置重复注释。 例如，您有一个用于处理未授权访问异常的类。 您可以使用一个@Alert注释为管理员注释该类，为管理员注释另一个注释：

```
@Alert(role="Manager")
@Alert(role="Administrator")
public class UnauthorizedAccessException extends SecurityException { ... }
```

出于兼容性原因，重复注释存储在由Java编译器自动生成的容器注释中。 为了使编译器执行此操作，代码中需要两个声明。

#### Step 1: Declare a Repeatable Annotation Type
注释类型必须使用@Repeatable元注释进行标记。 以下示例定义自定义@Schedule可重复注释类型：

```
import java.lang.annotation.Repeatable;

@Repeatable(Schedules.class)
public @interface Schedule {
  String dayOfMonth() default "first";
  String dayOfWeek() default "Mon";
  int hour() default 12;
}
```

@Repeatable元注释的值（在括号中）是Java编译器为存储重复注释而生成的容器注释的类型。 在此示例中，包含注释类型是Schedules，因此重复@Schedule注释存储在@Schedules注释中。
Applying the same annotation to a declaration without first declaring it to be repeatable results in a compile-time error.

#### Step 2: Declare the Containing Annotation Type
包含注释类型必须具有带数组类型的value元素。 数组类型的组件类型必须是可重复的注释类型。 包含注释类型的计划的声明如下：

```
public @interface Schedules {
    Schedule[] value();
}
```

#### Retrieving Annotations
Reflection API中有几种可用于检索注释的方法。 返回单个注释的方法（例如AnnotatedElement.getAnnotation（Class <T>））的行为未更改，因为如果存在所请求类型的一个注释，它们仅返回单个注释。 如果存在多个所请求类型的注释，则可以通过首先获取其容器注释来获取它们。 通过这种方式，遗留代码继续工作。 Java SE 8中引入了其他方法，它们扫描容器注释以一次返回多个注释，例如AnnotatedElement.getAnnotationsByType（Class <T>）。 有关所有可用方法的信息，请参阅AnnotatedElement类规范。

#### Design Considerations
设计注释类型时，必须考虑该类型注释的基数。 现在可以使用注释零次，一次，或者，如果注释的类型被标记为@Repeatable，则不止一次。 也可以通过使用@Target元注释来限制可以使用注释类型的位置。 例如，您可以创建只能在方法和字段上使用的可重复注释类型。 仔细设计注释类型非常重要，以确保使用注释的程序员发现它尽可能灵活和强大。

