## 1. The Reflection API
### 1.1 Uses of Reflection
反射通常由那些需要能够查验或修改在 Java 虚拟机中运行的应用程序的运行时行为的程序使用，这是一个相对高级的功能。考虑到反射是一种可以使应用程序执行本来不可能的操作的强大技术，因此只有那些对 Java 原理有很深理解的开发人员才能使用。


#### 1.1.1 Extensibility Features
应用程序可以通过完全限定名称创建可扩展性对象的实例来使用外部的用户定义类。

#### 1.1.2 Class Browsers and Visual Development Environments
类浏览器需要能够枚举类的成员，可视化开发环境可以从利用反射中可用的类型信息中受益，以帮助开发人员编写正确的代码。

#### 1.1.3 Debuggers and Test Tools
调试器需要能够查验类上的私有成员。测试工具可以利用反射系统地调用类上定义的可发现的 set API，以确保测试套件中的高等级代码覆盖率。

### 1.2 Drawbacks of Reflection
反射是强大的，但不应随意使用。如果可以在不使用反射的情况下执行操作，则优选避免使用它。通过反射访问代码时，应牢记以下问题。

#### 1.2.1 Performance Overhead
由于反射涉及动态解析的类型，因此无法执行某些 Java 虚拟机优化。因此，反射操作的性能低于非反射操作，并且应避免在性能敏感应用程序的频繁调用代码段中使用。

#### 1.2.2 Security Restrictions
反射需要运行时权限，这在安全管理器下运行时可能不存在。但对于必须在受限安全上下文中运行的代码，例如在 Applet 中，这是一个重要的考虑因素。

#### 1.2.3 Exposure of Internals
由于反射允许代码执行在非反射代码中非法的操作，例如访问 private 字段和方法，因此使用反射会导致意外的副作用，这可能导致代码功能失常并可能破坏可移植性。反射代码打破了抽象，因此可能会通过升级平台来改变行为。

### 1.3 rail Lessons
此 trail 包含用于访问和操作类、字段、方法和构造函数的反射的常见用法。每一节包含代码示例、提示和疑难解答信息。

#### 1.3.1 Classes
本课程介绍了获取 Class 对象的各种方法，并使用它来查验类的属性，包括其声明和内容。

#### 1.3.2 Members
本课程描述如何使用 Reflection API 查找类的字段、方法和构造函数。提供了用于设置和获取字段值、调用方法以及使用特定构造函数创建对象的新实例的示例。

#### 1.3.3 Arrays and Enumerated Types
本课介绍两种特殊类型的类：在运行时生成的 arrays 和定义唯一命名对象实例的 enum 类型。示例代码显示了如何检索数组的组件类型以及如何设置和获取具有数组或 enum 类型的字段。

> 注意：此 trail 中的示例旨在用于试验 Reflection API。因此，异常的处理与生产代码中使用的不同。特别是，在生产代码中，建议不要抛出用户可见的堆栈跟踪。

